package programmingtheiot.gda.connection;

import java.util.logging.Level;
import java.util.logging.Logger;

import org.eclipse.paho.client.mqttv3.IMqttMessageListener;
import org.eclipse.paho.client.mqttv3.MqttMessage;

import programmingtheiot.common.ConfigConst;
import programmingtheiot.common.ConfigUtil;
import programmingtheiot.common.IDataMessageListener;
import programmingtheiot.common.IConnectionListener;
import programmingtheiot.common.ResourceNameEnum;
import programmingtheiot.data.ActuatorData;
import programmingtheiot.data.DataUtil;
import programmingtheiot.data.SensorData;
import programmingtheiot.data.SystemPerformanceData;

/**
 * CloudClientConnector implements ICloudClient and IConnectionListener.
 * Delegates MQTT operations to MqttClientConnector for cloud service integration.
 * Handles incoming LED actuation events from cloud service.
 */
public class CloudClientConnector implements ICloudClient, IConnectionListener
{
    private static final Logger _Logger = 
        Logger.getLogger(CloudClientConnector.class.getName());
    
    private String topicPrefix = "";
    private String configSection = ConfigConst.CLOUD_GATEWAY_SERVICE;
    private MqttClientConnector mqttClient = null;
    private IDataMessageListener dataMsgListener = null;
    
    // Set to either 0 or 1, depending on which is preferred for your implementation
    private int qosLevel = 1;
    
    /**
     * Default constructor.
     * Uses the generic Cloud.GatewayService configuration section.
     */
    public CloudClientConnector()
    {
        this(ConfigConst.CLOUD_GATEWAY_SERVICE);
    }
    
    /**
     * Constructor with configuration section parameter.
     * Allows creation of cloud clients for specific cloud service providers.
     * 
     * @param configSection The configuration section to use (e.g., "Cloud.GatewayService.AWS")
     */
    public CloudClientConnector(String configSection)
    {
        super();
        
        if (configSection != null && configSection.trim().length() > 0) {
            this.configSection = configSection;
            _Logger.info("CloudClientConnector created with config section: " + this.configSection);
        } else {
            this.configSection = ConfigConst.CLOUD_GATEWAY_SERVICE;
            _Logger.warning("Invalid config section. Using default: " + this.configSection);
        }
        
        initializeConnection();
    }
    
    /**
     * Initializes the connection parameters from configuration.
     */
    private void initializeConnection()
    {
        ConfigUtil configUtil = ConfigUtil.getInstance();
    /**
     * Initializes the connection parameters from configuration.
     */
    private void initializeConnection()
    {
        ConfigUtil configUtil = ConfigUtil.getInstance();
        
        this.topicPrefix =
            configUtil.getProperty(this.configSection, ConfigConst.BASE_TOPIC_KEY);
        
        // Depending on the cloud service, the topic names may or may not begin with a "/", so this code
        // should be updated according to the cloud service provider's topic naming conventions
        if (topicPrefix == null) {
            topicPrefix = "/";
        } else {
            if (! topicPrefix.endsWith("/")) {
                topicPrefix += "/";
            }
        }
        
        _Logger.info("CloudClientConnector initialized with topic prefix: " + this.topicPrefix);
    }
    
    // ICloudClient implementation
    
    @Override
    public boolean connectClient()
    {
        if (this.mqttClient == null) {
            // Use the configured section for this cloud client
            this.mqttClient = new MqttClientConnector(this.configSection);
            
            // Set this as the connection listener
            this.mqttClient.setConnectionListener(this);
        }
        
        // NOTE: If MqttClientConnector is using the async client, we won't have a complete
        // connection to the cloud-hosted MQTT broker until MqttClientConnector's
        // connectComplete() callback is invoked, which will trigger onConnect().
        return this.mqttClient.connectClient();
    }
    
    @Override
    public boolean disconnectClient()
    {
        if (this.mqttClient != null && this.mqttClient.isConnected()) {
            return this.mqttClient.disconnectClient();
        }
        
        return false;
    }
    
    @Override
    public boolean setDataMessageListener(IDataMessageListener listener)
    {
        if (listener != null) {
            this.dataMsgListener = listener;
            _Logger.info("Data message listener set for CloudClientConnector.");
            return true;
        }
        
        return false;
    }
    
    @Override
    public boolean sendEdgeDataToCloud(ResourceNameEnum resource, SensorData data)
    {
        if (resource != null && data != null) {
            // Use standard JSON serialization
            String payload = DataUtil.getInstance().sensorDataToJson(data);
            
            return publishMessageToCloud(resource, data.getName(), payload);
        }
        
        return false;
    }
    
    @Override
    public boolean sendEdgeDataToCloud(ResourceNameEnum resource, SystemPerformanceData data)
    {
        if (resource != null && data != null) {
            // send the reading as a SensorData representation
            SensorData cpuData = new SensorData();
            cpuData.updateData(data);
            cpuData.setName(ConfigConst.CPU_UTIL_NAME);
            cpuData.setValue(data.getCpuUtilization());
            
            boolean cpuDataSuccess = sendEdgeDataToCloud(resource, cpuData);
            
            if (! cpuDataSuccess) {
                _Logger.warning("Failed to send CPU utilization data to cloud service.");
            }
            
            // send the reading as a SensorData representation
            SensorData memData = new SensorData();
            memData.updateData(data);
            memData.setName(ConfigConst.MEM_UTIL_NAME);
            memData.setValue(data.getMemoryUtilization());
            
            boolean memDataSuccess = sendEdgeDataToCloud(resource, memData);
            
            if (! memDataSuccess) {
                _Logger.warning("Failed to send memory utilization data to cloud service.");
            }
            
            return (cpuDataSuccess == memDataSuccess);
        }
        
        return false;
    }
    
    @Override
    public boolean subscribeToCloudEvents(ResourceNameEnum resource)
    {
        boolean success = false;
        
        String topicName = null;
        
        if (this.mqttClient != null && this.mqttClient.isConnected()) {
            topicName = createTopicName(resource);
            
            this.mqttClient.subscribeToTopic(topicName, this.qosLevel);
            
            success = true;
        } else {
            _Logger.warning("Subscription methods only available for MQTT. No MQTT connection to broker. Ignoring. Topic: " + topicName);
        }
        
        return success;
    }
    
    @Override
    public boolean unsubscribeFromCloudEvents(ResourceNameEnum resource)
    {
        boolean success = false;
        
        String topicName = null;
        
        if (this.mqttClient != null && this.mqttClient.isConnected()) {
            topicName = createTopicName(resource);
            
            this.mqttClient.unsubscribeFromTopic(topicName);
            
            success = true;
        } else {
            _Logger.warning("Unsubscribe method only available for MQTT. No MQTT connection to broker. Ignoring. Topic: " + topicName);
        }
        
        return success;
    }
    
    // IConnectionListener implementation
    
    @Override
    public void onConnect()
    {
        _Logger.info("Handling CSP subscriptions and device topic provisioning...");
        
        // Create LED enablement message listener
        LedEnablementMessageListener ledListener = new LedEnablementMessageListener(this.dataMsgListener);
        
        // Topic may not exist yet, so create a 'response' actuation event with invalid value -
        // this will create the relevant topic if it doesn't yet exist, which ensures
        // the message listener (if coded correctly) will log a message but ignore the
        // actuation command and NOT pass it onto the IDataMessageListener instance
        ActuatorData ad = new ActuatorData();
        ad.setAsResponse();
        ad.setName(ConfigConst.LED_ACTUATOR_NAME);
        ad.setValue((float) -1.0); // NOTE: this just needs to be an invalid actuation value
        
        String ledTopic = createTopicName(ledListener.getResource().getDeviceName(), ad.getName());
        
        _Logger.info("Creating LED actuation topic (if needed): " + ledTopic);
        
        // Use standard JSON serialization
        String adJson = DataUtil.getInstance().actuatorDataToJson(ad);
        
        this.publishMessageToCloud(ledTopic, adJson);
        
        // Subscribe to LED actuation topic with custom listener
        _Logger.info("Subscribing to LED actuation topic: " + ledTopic);
        this.mqttClient.subscribeToTopic(ledTopic, this.qosLevel, ledListener);
    }
    
    @Override
    public void onDisconnect()
    {
        _Logger.info("MQTT client disconnected from cloud service. Nothing else to do.");
    }
    
    // Private helper methods
    
    private String createTopicName(ResourceNameEnum resource)
    {
        return createTopicName(resource.getDeviceName(), resource.getResourceType());
    }
    
    private String createTopicName(ResourceNameEnum resource, String itemName)
    {
        return (createTopicName(resource) + "-" + itemName).toLowerCase();
    }
    
    /**
     * Creates a topic name from device name and resource type.
     * This method is protected to allow provider-specific subclasses to override.
     * 
     * @param deviceName The device name
     * @param resourceTypeName The resource type name
     * @return String The formatted topic name
     */
    protected String createTopicName(String deviceName, String resourceTypeName)
    {
        StringBuilder buf = new StringBuilder();
        
        if (deviceName != null && deviceName.trim().length() > 0) {
            buf.append(topicPrefix).append(deviceName);
        }
        
        if (resourceTypeName != null && resourceTypeName.trim().length() > 0) {
            buf.append('/').append(resourceTypeName);
        }
        
        return buf.toString().toLowerCase();
    }
    
    private boolean publishMessageToCloud(ResourceNameEnum resource, String itemName, String payload)
    {
        String topicName = createTopicName(resource, itemName);
        
        return publishMessageToCloud(topicName, payload);
    }
    
    private boolean publishMessageToCloud(String topicName, String payload)
    {
        try {
            _Logger.finest("Publishing payload value(s) to CSP: " + topicName);
            
            this.mqttClient.publishMessage(topicName, payload.getBytes(), this.qosLevel);
            
            return true;
        } catch (Exception e) {
            _Logger.warning("Failed to publish message to CSP: " + topicName);
        }
        
        return false;
    }
    
    // Inner class for handling LED actuation events from cloud
    
    /**
     * Inner class to handle LED actuation events received from cloud service.
     * Implements IMqttMessageListener to process incoming MQTT messages.
     */
    private class LedEnablementMessageListener implements IMqttMessageListener
    {
        private IDataMessageListener dataMsgListener = null;
        
        private ResourceNameEnum resource = ResourceNameEnum.CDA_ACTUATOR_CMD_RESOURCE;
        
        private int    typeID   = ConfigConst.LED_ACTUATOR_TYPE;
        private String itemName = ConfigConst.LED_ACTUATOR_NAME;
        
        LedEnablementMessageListener(IDataMessageListener dataMsgListener)
        {
            this.dataMsgListener = dataMsgListener;
        }
        
        public ResourceNameEnum getResource()
        {
            return this.resource;
        }
        
        @Override
        public void messageArrived(String topic, MqttMessage message) throws Exception
        {
            try {
                String jsonData = new String(message.getPayload());
                
                _Logger.info("Received LED actuation message from cloud: " + jsonData);
                
                ActuatorData actuatorData =
                    DataUtil.getInstance().jsonToActuatorData(jsonData);
                
                // This will have to match the CDA's location ID, depending on the
                // validation logic implemented within the CDA's ActuatorAdapterManager
                actuatorData.setLocationID(ConfigConst.CONSTRAINED_DEVICE);
                actuatorData.setTypeID(this.typeID);
                actuatorData.setName(this.itemName);
                
                int val = (int) actuatorData.getValue();
                
                switch (val) {
                    case ConfigConst.ON_COMMAND:
                        _Logger.info("Received LED enablement message [ON].");
                        actuatorData.setCommand(ConfigConst.COMMAND_ON);
                        actuatorData.setStateData("LED switching ON");
                        break;
                        
                    case ConfigConst.OFF_COMMAND:
                        _Logger.info("Received LED enablement message [OFF].");
                        actuatorData.setCommand(ConfigConst.COMMAND_OFF);
                        actuatorData.setStateData("LED switching OFF");
                        break;
                        
                    default:
                        _Logger.warning("Received invalid LED command value: " + val + ". Ignoring.");
                        return;
                }
                
                // Pass the ActuatorData command to DeviceDataManager for forwarding to CDA
                if (this.dataMsgListener != null) {
                    // Convert ActuatorData to JSON for validation and transmission
                    jsonData = DataUtil.getInstance().actuatorDataToJson(actuatorData);
                    
                    _Logger.info("Forwarding LED actuation command to DeviceDataManager: " + jsonData);
                    
                    // The implementation of IDataMessageListener (DeviceDataManager) will
                    // parse the JSON data and forward the actuator command to the CDA
                    this.dataMsgListener.handleIncomingMessage(
                        ResourceNameEnum.CDA_ACTUATOR_CMD_RESOURCE, jsonData);
                } else {
                    _Logger.warning("No data message listener set. Cannot forward LED actuation command.");
                }
            } catch (Exception e) {
                _Logger.log(Level.WARNING, "Failed to convert message payload to ActuatorData.", e);
            }
        }
    }
}